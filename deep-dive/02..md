---
description: Section 04 - 05
---

# 02. 변수

```
10 + 20 = 30
```

**04** 해당 구문을 자바스크립트는 연산자 + 와 피연산자 10, 20을 기억한다. 연산은 CPU가 기억은 메모리가 담당이다!

메모리는 **셀**로 이루어져 있고, 셀 하나의 크기는 **1dyte**다. 사진에는 편의상 10, 20, 30 으로 표현해두었으나 실제로는

2진수로 저장되어 있다.&#x20;

<figure><img src="../.gitbook/assets/image (2).png" alt="" width="249"><figcaption></figcaption></figure>

그럼 우리가 30 이라는 수를 재사용하고 싶다면 어떻게 해야할까? 메모리 주소(0x0669F913)을 써야하나?

하지만 매번 주소는 코드가 실행 될 때 마다 임의로 변경될 것이고 만약 메모리 주소를 사용하다 운영체제가

사용 중인 값을 실수로 변경 해버린다면..? ( 컴퓨터가 무지개 다리를 건널 수도... )

그\~래\~서! 우리는 **변수라는 친구를 통해 값을 저장 하기위해 확보한 메모리 공간을 식별** 한다.

그러니까 변수는 단순히 값의 위치를 가르키는 이름이다.

<figure><img src="../.gitbook/assets/image (1).png" alt="" width="300"><figcaption></figcaption></figure>

```javascript
var result = 10 + 20;
```

우리는 result라는 변수를 **선언**했고, result 변수 값을 **할당**했다.

&#x20;30이라는 값을 재사용하고 싶다면 result를 **참조** 하면된다.



자바스크립트에서는 변수를 선언할때 var, const, let 이렇게 3가지 방법이 있다.

const와 let은 ES6에서 나온 문법인데 var의 단점을 개선하기 위해 두두등장했다.

{% hint style="info" %}
var은 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다.

* 블록 레벨 스코프 : 블록(중괄호로 둘러싸인 코드 덩어리) 내부에서 선언 시 해당 블록 내에서만 유효
* 함수 레벨 스코프 : 선언 함수 내에서만 유효

```
// 함수 레벨 스코프 단점
function foo() {
  var x = 10;
  console.log(x); // 출력: 10
}
console.log(x); // 오류: x는 정의되지 않음
```
{% endhint %}

```
var temp;
```

해당 선언문 실행시 메모리에 변수 이름(temp)을 등록하고 저장할 메모리 공간을 확보한다.

그 후 undefined로 변수를 초기화한다. (요곤 몰랐네...😅) 이렇게 초기화하지 않으면 이전에 다른 어플리케이션에서

사용하던 값이 남아 있을 수 있다.

\* 이런 변수와 같은 식별자들의 정보는 실행 컨텍스트에 key, value 형식으로 저장하여 관리하는데 뒷 부분에서&#x20;

자세히 알아보도록 하겠다.





**04.4** 드디어 호이스팅 🥳

```
console.log(score);
var score;
```

위의 코드는 과연 참조에러(ReferenceError)가 나타나는가? 결과는 undefined가 나온다.

이유는 변수 선언이 런타임이 아니라 이전 단계에서 실행 된다.

맨 처음 자바스크립트가 인터프리터 언어라고 했지만 애매했던 부분이 이부분이다.

자바스크립트는 한 줄씩 실행하기전에 사실은 Tokenizing > Parsing > Code-Gen 이 세단계가 발생하고 난 뒤

코드를 실행한다. 요약하자면 코드를 토큰처럼 분리하고 > 코드 트리를 만든 뒤 > 최적화 작업이다.

이 단계에서 변수를 먼저 선언하고 (위에서 선언후 undefined 자동으로 초기화) 실행하면서 console.log를 실행

하니 undefined라는 값이 나온다.

이처럼 **변수의 선언문이 위로 끌어 올려진것 처럼 동작하는 자바스크립트의 특징을 호이스팅** 이라고 한다.





04.5 재할당 부분이다. (사실 이 부분 보면서 몰랐다..) 아래의 사진만 보면 다 이해 간다.

<figure><img src="../.gitbook/assets/image (2) (1).png" alt="" width="563"><figcaption></figcaption></figure>

변수 선언 후 자바스크립트에서 자동으로 undefined로 초기화 해주었고, 그다음 80에서 90으로 재할당 된다.

만약 재할당을 하지 않고 싶다면 우리는 변수가 아니라 **상수**(const)를 사용해야한다.

나는 재할당하면 메모리에 값이 업데이트 되는 줄 알았는데.. 그럼 80과 undefined는 불필요한 공간만 차지

하고 있는 것 아닌가? 했더니\~ 우리에겐 **가비지 콜렉터**(Garbage collector)가 있다.

가비지 콜렉터에 의해 자동으로 메모리에서 해제되는데 시점을 알 순 없다.

\* 이렇게 가비지 콜렉터에 의해 자동으로 관리되면 매니지드(Managed) 언어, C처럼 개발자가 명시적으로 메모리

제어를 해줘야 하는 언어는 언매니지드 언어라고 한다.



네이밍 규칙은 넘어가겠다.. 뭐 앞에 숫자면 안되구 - 안되구 등등...&#x20;

아래는 네이밍 규칙 3가지이다.

```javascript
// 카멜 케이스 (Camel Case)
var firstName;

// 스네이트 케이스 (Snake Case)
var first-name;

// 파스칼 케이스 (Pascal Case)
var FirstName;
```



**05.** 표현식과 문에 대한 장이다. 키워드만 정리하고 넘어가려 한다.

* 값: 식이 평가되어 생성된 결과
* 리터럴: 사람들이 이해할 수 있는 약속된 기호를 사용하여 생성하는 표기법
* 표현식: 값으로 평가 될 수 있는 문
*  문: 프로그램을 구성하는 최소 단위

